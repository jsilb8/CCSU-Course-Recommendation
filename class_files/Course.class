<?php

class Course {

    public $db_id;
    public $des;
    public $num;
    public $name;
    public $credit;
    public $description;
    public $catalog_url;
    public $prereq_group;
    public $priority;
    public $group_id;
    public $term;

    // Constructor
    public function __construct($courseID = false) {
        if(is_object($courseID)) print_c($courseID);
        if ($courseID)
            $course = DB::query_array("SELECT * FROM `course` WHERE `courseID`='" . $courseID . "' LIMIT 1");
        $this->build_course($course);
    }

    //constructor using courseID
    public static function from_id($courseID) {
        if ($courseID)
            return new Course($courseID);
        return false;
    }

    //constructor using course des and num
    public static function from_code($des, $num) {
        $courseID = DB::query_value("SELECT * FROM `course` WHERE `des`='" . $des . "' AND `num`='" . $num . "' LIMIT 1", "courseID");
        if ($courseID)
            return new Course($courseID);
        return false;
    }
    
    //assign values to a course object's variables
    protected function build_course($data) {
        $this->db_id = $data['courseID'];
        $this->des = $data['des'];
        $this->num = $data['num'];
        $this->name = $data['name'];
        $this->credit = $data['credits'];
        $this->description = $data['description'];
        $this->catalog_url = $data['catalogURL'];
        $this->prereq_group = DB::query_value("SELECT groupID FROM `groups` WHERE parentCourseID = '" . $this->db_id . "'", "groupID");
        $this->priority = $data['priority'];
        $this->term = $data['term'];
    }
    
    //print course object
    public function __toString() {
        return '<span>' . $this->des . ' ' . $this->num . '</span> <span>' . $this->name . '</span>';
    }
    
    // Used for sorting arrays of course objects
    static function cmp_sort($course1,$course2){
        $course1 = $course1->__toString();
        $course2 = $course2->__toString();
        if ($course1 == $course2) return 0;
        return ($course1 > $course2) ? +1 : -1;
    }
    
     //sort two course objects by credit descending
    public static function sortByCredit($a, $b) 
    {
        if($a->credit == $b->credit)
       { 
            return 0 ; 
       }
        return ($a->credit > $b->credit) ? -1 : 1;
    }
    
    //sort two course objects by priority descending
    public static function sortByPriority($b, $a) 
    {
        if($a->priority == $b->priority){ return 0 ; }
            return ($a->priority < $b->priority) ? -1 : 1;
    }
    
    //sort two course objects by priority ascending
    public static function sortByPriorityAsc($b, $a) 
    {
        if($a->priority == $b->priority){ return 0 ; }
            return ($a->priority < $b->priority) ? -1 : 1;
    }
    
    //static method that returns a prereq group if the input course has one
    public static function get_has_prereq_group($course_id){
        return query_exists("SELECT groupID FROM `groups` WHERE parentCourseID = '" . $course_id . "' LIMIT 1");
    }

    //returns a prereq group if the target course object has one
    public function get_prereq_group() {
        if ($this->db_id) {
            $pg = new Prereq_Group($pid);

            return $pg;
        } else {
            return false;
        }
    }

    //returns all course prereq groups containing the input course
    public static function get_parent_groups($db_id) {
        $parGroups = DB::query_array_col("SELECT g.groupID FROM `groupHasGroupOrCourse` `g` JOIN groups `c` ON g.groupID=c.groupID WHERE g.courseID='" . $db_id . "' AND c.partOfProgram IS NULL", "groupID");
        if ($parGroups) {
            foreach ($parGroups as $groupID) {
                $parent[] = $groupID;
            }
            return $parent;
        }
    }

    //for a given course, return all the courses that have it as a prerequisite as long as they're on the input relevant list of courses
    public static function get_master_course_list($courseID, $relevantList) {
        $c = new Course($courseID);
        $parentGroupIDs = Course::get_parent_groups($courseID);
        if ($parentGroupIDs) {
            foreach ($parentGroupIDs as $pid) {
                $pg = new Prereq_Group($pid);
                if ($pg->parent_course) {
                    $pcid = $pg->parentCourseID;
                    if ($relevantList) {
                        foreach ($relevantList as $rid) {
                            if ($pcid == $rid) {
                                $m[] = $pcid;
                            }
                        }
                    }
                } else {
                    $parentID = Prereq_Group::get_parent_group($pid);
                    $PG = new Prereq_Group($parentID);
                    $hasPC = false;
                    while (!$hasPC) {
                        $id = $PG->db_id;
                        if ($PG->parent_course) {
                            $pcid2 = $PG->parentCourseID;
                            if ($relevantList) {
                                foreach ($relevantList as $rid) {
                                    if ($pcid2 == $rid) {
                                        $m[] = $pcid2;
                                    }
                                }
                            }
                            $hasPC = true;
                        } else {
                            $PG = new Prereq_Group(Prereq_Group::get_parent_group($id));
                        }
                    }
                }
            }
            return $m;
        } else {
            return false;
        }
    }

    
    //return all courses from the input required list that are made available as a result of taking the input course
    public static function getCoursesMadeAvail($courseID, $requiredCourses, $list, $avail) {
        $ml = Course::get_master_course_list($courseID, $requiredCourses);
        if ($ml) {
            foreach ($ml as $id) {
                $c = new Course($id);
                $pg = new Prereq_Group($c->prereq_group);
                if (Prereq_Group::check_completion($pg, $list) == 1) {
                    $exists = false;
                    for ($y = 0; $y < count($avail); $y++) {
                        if ($avail[$y]) {
                            if ($id == $avail[$y]) {
                                $exists = true;
                            }
                        }
                    }
                    if (!$exists) {
                        $final[] = $id;
                    }
                }
            }
            return $final;
        }
    }

    //return the length of the deepest chain of a given course, based on a list of courses that make up the graph containing the chain
    private static function getMaxDepth($courseID, $relevantList) {
        $count = array();
        $count2 = 0;
        $ml = Course::get_master_course_list($courseID, $relevantList);
        if ($ml) {
            foreach ($ml as $id) {
                $count[$id] ++;

                $list = $relevantList;

                if (Course::get_master_course_list($id, $relevantList)) {
                    $count[$id] += Course::getMaxDepth($id, $list);
                }
            }
            foreach ($count as $priority) {
                if ($priority > $count2) {
                    $count2 = $priority;
                }
            }
            return $count2;
        } else {
            return 0;
        }
    }

    //return the breadth of a given course (the number of courses that directly require it), based on a list of courses that make up its graph
    private static function getBreadth($courseID, $relevantList) {
        $ml = Course::get_master_course_list($courseID, $relevantList);
        if ($ml) {

            return count($ml) / 5;
        } else {
            return 0;
        }
    }

    
    //return the priority of the input course given the list of input courses taken. Priority here is either the course's max depth, or its breadth, whichever is greater. 
    //add an additional 1 to the priority if the course isn't offered every semester
    public static function getPriority($courseID, $takenList) {
        $depth = Course::getMaxDepth($courseID, $takenList);
        $breadth = Course::getBreadth($courseID, $takenList);
        $c = new Course($courseID);
        if ($depth > $breadth) {
            //if the course is offered only fall or only spring, add 1 to its priority
            if($c->term == 0 OR $c->term == 1 OR $c->term == 3)
            {
                $depth++;
            }
            return $depth;
        } else {
            //if the course is offered only fall or only spring, add 1 to its priority
            if($c->term == 0 OR $c->term == 1 OR $c->term == 3)
            {
                $breadth++;
            }
            return $breadth;
        }
    }
}
